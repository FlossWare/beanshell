/**
 * BUnit - JUnit ala beanshell:
 *   - All tests are assumed to end in *Test.bsh
 *   - Within a test file, methods that start with test are considered test methods.
 *   - If an exception is expected to be raised, those exception types should be included in test method parameters.
 *   - The following methods will be called if present in the test script:
 *     - beforeClass():  will be called when the test is instantiated.
 *     - afterClass():   will be called when all tests have been run.
 *     - before():       will be called before each test is run.
 *     - after():        will be called after each test is run.
 */
BUnit() {
    fileUtils = FileUtils();

    /**
     * Return all test files found in dir.
     *
     * @param dir is the directory containing test files.
     */
    File[] findAllTestFiles(File dir) {
        return fileUtils.findByExtension(dir, "Test.bsh");
    }

    /**
     * Return all test files found in dir.
     *
     * @param dir is the directory containing test files.
     */
    File[] findAllTestFiles(String dir) {
        return findAllTestFiles(new File(dir));
    }

    /**
     * Return true if methodName starts with test.
     *
     * @return true if methodName starts with test.
     */
    boolean isTestMethod(String methodName) {
        return methodName.startsWith("test");
    }

    /**
     * Compute the failure message.
     *
     * @param targetError the error raised when a method was called.
     *
     * @return the compute message.
     */
    String computeFailureMessage(error) {
        return "        " + error.toString().replaceAll("\n", "\n        ");
    }
    
    /**
     * Return true if there are parameters.
     *
     * @param bshMethod contains the parameters.
     *
     * @return true if there are parameters for this method.
     */
    boolean isParameters(bsh.BshMethod bshMethod) {
        return bshMethod.getParameterTypes().length > 0;
    }

    /**
     * Process the failures raised in targetError.
     *
     * @param bshMethod the method that was tested when a failure arose.
     * @param targetError the error that arose.
     */
    void processFailures(bsh.BshMethod bshMethod, bsh.TargetError targetError) {
        for(Class klass : bshMethod.getParameterTypes()) {
            if (klass.isAssignableFrom(targetError.getTarget().getClass())) {
                print("    Passed:  " + bshMethod.getName());
                
                return;
            }
        }

        print("    Failed:  " + bshMethod.getName());
        print("             Unexpected exception raised:  " + targetError.getTarget().getClass().getName());
        print(computeFailureMessage(targetError));

        throw targetError;
    }

    /**
     * When testing a method and a failure arise, process it here...
     *
     * @param toTest the object being tested.
     * @param bshMethod the test method.
     * @param targetError the error raised when the method was called.
     */
    void processFailure(toTest, bsh.BshMethod bshMethod, bsh.TargetError targetError) {
        if (!isParameters(bshMethod)) {
            print("    Failed:  " + bshMethod.getName());
            print(computeFailureMessage(targetError));

            throw targetError;
        }

        processFailures(bshMethod, targetError);
    }

    /**
     * When a test method passes successfully, we want to ensure we didn't
     * have any parameters that denoted an exception should have been raised.
     *
     * @param bshMethod is the test method that passed successfully.
     */
    void processSuccess(bsh.BshMethod bshMethod) {
        if (!isParameters(bshMethod)) {
            print("    Passed:  " + bshMethod.getName());

            return;
        }

        List classList = Arrays.asList(bshMethod.getParameterTypes());
        List classStrList = new ArrayList(classList.size());
        for (Class klass : classList) {
            classStrList.add(klass.getName());
        }

        print("    Failed:  " + bshMethod.getName());
        print("        Expected one of " + classStrList.toString().replaceAll("\\[", "").replaceAll("\\]", ""));

        System.exit(1);
    }

    /**
     * Test a method on an object.
     *
     * @param toTest is the object to test.
     * @param bshMethod is the beanshell method to test.
     */
    void testMethod(toTest, bsh.BshMethod bshMethod) {
        try {
            toTest.invokeMethod(bshMethod.getName(), new Object[bshMethod.getParameterTypes().length]);

            processSuccess(bshMethod);
        } catch(bsh.TargetError targetError) {
            processFailure(toTest, bshMethod, targetError);
        }
    }

    /**
     * Execute one of the housekeeping methods like beforeClass, afterClass, before and after.
     *
     * @param toTest is the object to run the housekeeping methods on.
     * @param bshMethod is the housekeeping method to run.
     */
    void runHouseKeepingMethod(toTest, bsh.BshMethod bshMethod) {
        if (null == bshMethod) {
            return;
        }

        try {
            toTest.invokeMethod(bshMethod.getName(), new Object[bshMethod.getParameterTypes().length]);
        } catch(bsh.TargetError targetError) {
            print("    WARNING:  Trouble executing housekeeping method [" + bshMethod.getName() + "]");
            print(computeFailureMessage(targetError));
        }
    }

    /**
     * Execute the before() method on toTest.
     *
     * @param toTest is the object to test.
     */
    void runBefore(toTest) {
        runHouseKeepingMethod(toTest, toTest.namespace.methods.get("before"));
    }

    /**
     * Execute the after() method on toTest.
     *
     * @param toTest is the object to test.
     */
    void runAfter(toTest) {
        runHouseKeepingMethod(toTest, toTest.namespace.methods.get("after"));
    }

    /**
     * Test an inidividual method on an object.
     *
     * @param toTest the object to test.
     * @param methodName is the name of the method to test.
     */
    void testMethod(toTest, String methodName) {
        if (!isTestMethod(methodName)) {
            return;
        }
        
        runBefore(toTest);

        bsh.TargetError realFailure = null;

        try {
            testMethod(toTest, toTest.namespace.methods.get(methodName));
        } catch(bsh.TargetError targetError) {
            realFailure = targetError;
        } catch(bsh.EvalError evalError) {
            print("    WARNING:  Could not test " + methodName + ":");
            print(computeFailureMessage(evalError));
        }

        runAfter(toTest);

        if (null != realFailure) {
            throw realFailure;
        }
    }

    /**
     * Test an inidividual method on an object.
     *
     * @param toTest the object to test.
     * @param methodNames is the name of the method to test.
     */
    void testMethod(toTest, List methods) {
        List duplicateMethods = new ArrayList(methods.size());

        for (bsh.BshMethod method : methods) {
            duplicateMethods.add(method.getName() + "()");
        }

        print("    Failed:  Duplicate test methods failed!");
        print("        " + duplicateMethods.toString().replaceAll("\\[", "").replaceAll("\\]", ""));

        System.exit(1);
    }

    /**
     * Test an object.
     *
     * @param toTest the object to test.
     * @param methods are the methods on the object to test.
     */
    void testObject(toTest, Set methods) {
        for (String method : toTest.namespace.methods.keySet()) {
            testMethod(toTest, method);
        }
    }

    /**
     * Execute the beforeClass() method.
     */
    void runBeforeClass(toTest) {
        runHouseKeepingMethod(toTest, toTest.namespace.methods.get("beforeClass"));
    }

    /**
     * Execute the beforeClass() method.
     */
    void runAfterClass(toTest) {
        runHouseKeepingMethod(toTest, toTest.namespace.methods.get("afterClass"));
    }

    /**
     * Determine if toTest has any methods.
     *
     * @param toTest the object to examine if contains methods.
     *
     * @return true if methods are available.
     */
    boolean containsMethods(toTest) {
        return null != toTest.namespace.methods;
    }

    /**
     * Test a test file.
     *
     * @param testFile is the file to test.
     */
    void runTest(File testFile) {
        importCommands(".");

        try {
            eval("toTest=" + fileUtils.computeBaseName(testFile) + "()");
        } catch(bsh.EvalError evalError) {
            print("    WARNING:  Could not test " + testFile.getName() + ":");
            print(computeFailureMessage(evalError));
            return;
        }

        if (!containsMethods(toTest)) {
            print("    WARNING:  No methods found - skipping!");

            return;
        }

        runBeforeClass(toTest);

        bsh.TargetError realFailure = null;

        try {
            testObject(toTest, toTest.namespace.methods.keySet());
        } catch(bsh.TargetError targetError) {
            realFailure = targetError;
        } catch(bsh.EvalError evalError) {
            realFailure = evalError;
        }

        runAfterClass(toTest);

        if (null != realFailure) {
            System.exit(1);
        }
    }

    /**
     * Run tests found in testFiles.
     *
     * @param testFiles an array of files to test.
     */
    void runTests(File[] testFiles) {
        for (File testFile : testFiles) {
            print(testFile.getName());

            runTest(testFile);

            print("");
        }
    }

    /**
     * Run all tests found in testDir using the source found in srcDir.
     *
     * @param srcDir is the directory containing source files.
     * @param testDir is the directory containing test files.
     * @param stopOnError if true, test run will stop when failure arises.
     */
    void runTests(String srcDir, String testDir) {
        addClassPath(srcDir);
        addClassPath(testDir);

        runTests(findAllTestFiles(testDir));
    }

    return this;
}